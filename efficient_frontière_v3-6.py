# -*- coding: utf-8 -*-
"""efficient frontière V3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ORJR3YMtvzMOBvZ1HzUqVpe1LwTb6FRJ

`ORIGINAL`
"""



'''

 ___  __  __  ___  ___  ____    ____  ____  ____  ____  ____  _____
/ __)(  )(  )/ __)/ __)(_  _)  (  _ \( ___)(  _ \(_  _)(_  _)(  _  )
( (_-. )(__)(( (__( (__  _)(_    )___/ )__)  )___/ _)(_   )(   )(_)(
\___/(______)\___)\___)(____)  (__)  (____)(__)  (____) (__) (_____)
 ____  ____  ____  ____  ___  ____  ____  _  _  ____    ____  ____  _____  _  _  ____  ____  ____  ____  ____
( ___)( ___)( ___)(_  _)/ __)(_  _)( ___)( \( )(_  _)  ( ___)(  _ \(  _  )( \( )(_  _)(_  _)( ___)(  _ \( ___)
)__)  )__)  )__)  _)(_( (__  _)(_  )__)  )  (   )(     )__)  )   / )(_)(  )  (   )(   _)(_  )__)  )   / )__)
(____)(__)  (__)  (____)\___)(____)(____)(_)\_) (__)   (__)  (_)\_)(_____)(_)\_) (__) (____)(____)(_)\_)(____)

'''




!pip install pandas numpy yfinance pyportfolioopt matplotlib sklearn scikit-learn spicy
!pip install numpy
!pip install pandas
!pip install matplotlib
!pip install seaborn
!pip install sklearn
!pip install xgboost
!pip install yfinance
!pip install pypfopt
!pip install scipy


import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import yfinance as yf
from pypfopt import expected_returns, risk_models
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

# Charger les données depuis un fichier Excel
#file_path = 'tickers1.xlsx'
#df = pd.read_excel(file_path, sheet_name='ag-grid')

# Indexer les tickers pour faciliter les recherches
#df = df.set_index('Ticker')

# Accéder à une liste de tickers
#tickers_list = df.index.tolist()

# Liste des tickers qui ont provoqué des erreurs
#tickers_with_errors = ['ABC', 'PXD', 'RCI.B.TO', 'GIB.A.TO', 'DISCA', 'BLL', 'PPD', 'ATD.B.TO', 'VIAC', 'BRK.A']

# Filtrer le DataFrame original pour exclure les tickers avec des erreurs
#cleaned_df = df[~df.index.isin(tickers_with_errors)]

#new_ticker_list = cleaned_df.index.tolist()


def get_price_history(tickers, sdate, edate):
    """
    Télécharge l'historique des prix de clôture ajustés pour les tickers spécifiés depuis Yahoo Finance.

    Args:
    - tickers (list/str): Liste ou chaîne de caractères des tickers des actions à télécharger.
    - sdate (str): Date de début au format 'AAAA-MM-JJ'.
    - edate (str): Date de fin au format 'AAAA-MM-JJ'.

    Returns:
    - pandas.DataFrame: DataFrame contenant les prix de clôture ajustés pour les tickers spécifiés.
    """
    data = yf.download(tickers, start=sdate, end=edate)['Adj Close']
    return data

# Définition des tickers et des dates de début et fin
tickers = ['BFH', 'SDE.TO']
start = '2024-01-01'  # Date de début correctement formatée
end = '2024-08-01'

# Téléchargement des prix de clôture ajustés des tickers spécifiés
prices_df = get_price_history(' '.join(tickers), sdate=start, edate=end)
returns_df = prices_df.pct_change()[1:]

# Calcul du VaR historique
confidence_level = 0.95  # Niveau de confiance pour le VaR
VaR = returns_df.quantile(1 - confidence_level)

# Titre du graphique
title = 'Performance des Actions'

# Création et affichage du graphique de performance des actions
plt.figure(figsize=(10, 6))
for c in prices_df.columns:
    plt.plot(prices_df.index, prices_df[c], label=c)

plt.title(title)
plt.xlabel('Date (Années)', fontsize=10)
plt.ylabel('Prix USD (Clôture ajustée)', fontsize=10)
plt.legend(prices_df.columns.values, loc='upper left')
plt.grid(axis='y')
plt.text(0.99, 0.01, 'guccipepito', transform=plt.gca().transAxes,
         fontsize=10, color='black', ha='right', va='bottom', alpha=0.5)
plt.tight_layout()
plt.savefig('performance_actions.png', dpi=300)
plt.show()

# vecteur de rendement et matrice de covariance
r = ((1 + returns_df).prod()) ** (252 / len(returns_df)) - 1  # calcul des rendements annuels
cov = returns_df.cov() * 252  # matrice de covariance annualisée

# vecteur de uns égal au nombre d'actions
e = np.ones(len(r))  # vecteur de uns de la même longueur que le nombre d'actions

# calculer les rendements historiques moyens des actifs
mu = expected_returns.mean_historical_return(prices_df)  # rendement historique moyen


# Calculer la matrice de covariance échantillon des rendements des actifs
S = risk_models.sample_cov(prices_df)

# Appliquer la régularisation par le Shrinkage
S = risk_models.CovarianceShrinkage(prices_df).ledoit_wolf()

# Forcer la symétrie de la matrice de covariance
S = (S + S.T) / 2

# Créer un objet Frontière Efficiente en utilisant les rendements moyens et la matrice de covariance
ef = EfficientFrontier(mu, S)


# trouver les poids du portefeuille qui maximisent le ratio de Sharpe
raw_weights = ef.max_sharpe()  # optimiser pour le ratio de Sharpe maximum

# nettoyer les poids bruts pour les rendre plus pratiques (par exemple, arrondir les petits poids à zéro)
cleaned_weights = ef.clean_weights()  # nettoyer les poids bruts

# obtenir les prix les plus récents des actifs
latest_prices = get_latest_prices(prices_df)  # obtenir les derniers prix des actifs

# définir les poids du portefeuille aux poids nettoyés
weights = cleaned_weights  # assigner les poids nettoyés au portefeuille

# créer un objet Allocation Discrète avec les poids du portefeuille, les derniers prix et la valeur totale du portefeuille
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value=3000)  # initialiser l'Allocation Discrète #-------------------#

# calculer l'allocation discrète des actifs dans le portefeuille et les fonds restants
allocation, leftover = da.greedy_portfolio()  # calculer l'allocation des actifs et les fonds restants


# définir l'univers investissable et les facettes d'optimisation du risque-rendement du portefeuille efficient selon la théorie moderne du portefeuille
icov = np.linalg.inv(cov)  # matrice de covariance inverse
h = np.matmul(e, icov)  # vecteur h
g = np.matmul(r, icov)  # vecteur g
a = np.sum(e * h)  # somme des éléments du vecteur e*h
b = np.sum(r * h)  # somme des éléments du vecteur r*h
c = np.sum(r * g)  # somme des éléments du vecteur r*g
d = a * c - b**2  # calcul de la variable d

# portefeuille de tangence minimum et variance
mvp = h / a  # portefeuille de minimum variance
mvp_returns = b / a  # rendements du portefeuille de minimum variance
mvp_risk = (1 / a) ** (1 / 2)  # risque du portefeuille de minimum variance

# portefeuille de tangence
tagency = g / b  # portefeuille de tangence
tagency_returns = c / b  # rendements du portefeuille de tangence
tagency_risk = c ** (1 / 2) / b  # risque du portefeuille de tangence

# Calculer les rendements attendus minimum et maximum à partir du dataframe mu
min_expected_return = mu.min()  # rendement attendu minimum
max_expected_return = mu.max()  # rendement attendu maximum

# Utiliser ces valeurs pour définir le range de exp_returns
exp_returns = np.linspace(min_expected_return, max_expected_return, num=100)  # définir une plage de rendements attendus

# Utiliser le reste du code pour calculer et tracer l'efficience frontière
risk = ((a * exp_returns ** 2 - 2 * b * exp_returns + c) / d) ** (1 / 2)  # calculer le risque pour la frontière efficiente

# Tracé de l'efficience frontière pour un rapport professionnel
plt.figure(figsize=(10, 6))  # Taille professionnelle de la figure

# Courbe de l'efficience frontière avec ligne pointillée bleue
plt.plot(risk, exp_returns, linestyle='--', color='b', linewidth=2, label='Frontière Efficient')

# Point représentant le portefeuille à variance minimale
plt.scatter(mvp_risk, mvp_returns, marker='*', color='r', s=200, label='Portefeuille de Volatilité Minimale')

# Point représentant le portefeuille optimal en termes de risque
plt.scatter(tagency_risk, tagency_returns, marker='*', color='g', s=200, label='Portefeuille Optimal en Risque')

# Titres et labels des axes avec tailles de police adaptées
plt.title("Frontière Efficiente", fontsize=14)
plt.xlabel("Écart-type (Risque)", fontsize=12)
plt.ylabel("Rendement Attendu", fontsize=12)
plt.grid(True, axis='y', linestyle='--', alpha=0.7)  # Quadrillage léger en pointillé

# Légende avec positionnement optimisé
plt.legend(loc="lower right", fontsize=10)

# Ajout de "guccipepito" en bas à gauche
plt.text(0.01, 0.01, 'guccipepito', transform=plt.gca().transAxes,
         fontsize=10, color='black', ha='left', va='bottom', alpha=0.5)

# Ajustement automatique de la mise en page
plt.tight_layout()

# Sauvegarde du graphique en format PNG haute résolution pour le rapport
plt.savefig('efficience_frontiere.png', dpi=300)

# Affichage du graphique
plt.show()


# Tracé de la ligne de marché des titres (Securities Market Line - SML)
SML_slope = 1 / c**(1 / 2)  # pente de la ligne de marché des titres (SML)
SML_risk = exp_returns * SML_slope  # risque sur l'axe x pour la SML

plt.figure(figsize=(10, 6))  # Taille de la figure

# Courbe de l'efficience frontière en pointillés bleus
plt.plot(risk, exp_returns, color='b', linestyle='--', linewidth=2)

# Ligne de marché des titres (SML) en tiret-point rouge
plt.plot(SML_risk, exp_returns, color='r', linestyle='-.', linewidth=2)

# Point du portefeuille à variance minimale en rouge
plt.scatter(mvp_risk, mvp_returns, marker='*', color='r', s=200, label='Portefeuille de Volatilité Minimale')

# Point du portefeuille optimal en termes de risque en vert
plt.scatter(tagency_risk, tagency_returns, marker='*', color='g', s=200, label='Portefeuille Optimal en Risque')

# Titre et étiquettes des axes avec des tailles de police adaptées
plt.title("Frontière Efficiente & Ligne de Marché des Titres", fontsize=14)
plt.xlabel("Écart-type (Risque)", fontsize=12)
plt.ylabel("Rendement Attendu", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Quadrillage sur l'axe y

# Légende avec position optimisée dans le coin inférieur droit
plt.legend(["Frontière Efficiente", "Ligne de Marché des Titres (SML)", "Portefeuille de Volatilité Minimale", "Portefeuille Optimal en Risque"], loc="lower right", fontsize=10)

# Ajout de "guccipepito" en bas à gauche en noir
plt.text(0.01, 0.01, 'guccipepito', transform=plt.gca().transAxes,
         fontsize=10, color='black', ha='left', va='bottom', alpha=0.5)

# Ajustement automatique de la mise en page
plt.tight_layout()

# Sauvegarde du graphique en format PNG haute résolution pour le rapport
plt.savefig('efficience_frontiere_sml.png', dpi=300)

# Affichage du graphique
plt.show()

# Résolution du problème de rendement cible
target_return = tagency_returns  # définition du rendement cible
target_risk = tagency_risk  # définition du risque cible

if target_return < mvp_returns:
    # Si le rendement cible est inférieur au rendement du portefeuille à variance minimale
    optimal_portfolio = mvp  # portefeuille optimal est le portefeuille à variance minimale
    optimal_return = mvp_returns  # rendement optimal est le rendement du portefeuille à variance minimale
    optimal_risk = mvp_risk  # risque optimal est le risque du portefeuille à variance minimale
else:
    # Sinon, calculer les poids du portefeuille optimal pour atteindre le rendement cible
    l = (c - b * target_return) / d
    m = (a * target_return - b) / d
    optimal_portfolio = l * h + m * g  # calcul des poids du portefeuille optimal
    optimal_return = np.sum(optimal_portfolio * r)  # calcul du rendement du portefeuille optimal
    optimal_risk = ((a * optimal_return ** 2 - 2 * b * optimal_return + c) / d) ** (1 / 2)  # calcul du risque du portefeuille optimal

# Récupération des performances du portefeuille
annual_return, annual_volatility, sharpe_ratio = ef.portfolio_performance(verbose=True)

# Création du graphique pour les performances du portefeuille et poids nettoyés
fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Texte des performances du portefeuille
performance_text = f"Rendement annuel attendu : {annual_return * 100:.1f}%\n" \
                   f"Volatilité annuelle : {annual_volatility * 100:.1f}%\n" \
                   f"Ratio de Sharpe : {sharpe_ratio:.2f}"
axs[0, 0].text(0.1, 0.5, performance_text, fontsize=12, ha='left', va='center')
axs[0, 0].axis('off')  # Désactive les axes pour ce sous-graphique
axs[0, 0].set_title('Performances du Portefeuille')

# Graphique des poids nettoyés du portefeuille
axs[0, 1].bar(weights.keys(), weights.values())
axs[0, 1].set_title('Poids Nettoyés du Portefeuille')
axs[0, 1].set_xlabel('Actifs')
axs[0, 1].set_ylabel('Poids')
axs[0, 1].tick_params(axis='x', rotation=45)

# Graphique de l'allocation discrète des actifs
axs[1, 0].pie(list(allocation.values()), labels=list(allocation.keys()), autopct='%1.1f%%', startangle=140)
axs[1, 0].set_title('Allocation Discrète des Actifs')

# Graphique des fonds restants après l'allocation
axs[1, 1].text(0.5, 0.5, f"Fonds restants :\n{leftover:.2f} CAD", fontsize=14, ha='center', va='center')
axs[1, 1].axis('off')
axs[1, 1].set_title('Fonds Restants')

# Ajout de la légende spécifique en bas à droite
fig.text(0.95, 0.05, 'guccipepito', fontsize=12, color='black', ha='right', va='bottom', alpha=0.5)

# Ajustement de l'espacement entre les sous-graphiques
plt.tight_layout()

# Affichage du graphique
plt.show()

# Impression de l'allocation discrète du portefeuille et des fonds restants
print(f"Allocation Discrète du Portefeuille: {allocation}")
print(f"Fonds Restants: {leftover:.2f}")

'''
Usually, any Sharpe ratio greater than 1.0 is considered acceptable to good by investors.
A ratio higher than 2.0 is rated as very good.
A ratio of 3.0 or higher is considered excellent.
A ratio under 1.0 is considered sub-optimal.
'''

allocation

optimal_portfolio

mvp

cleaned_weights

# Affichage du VaR
print(f"Value at Risk (VaR) à {confidence_level * 100}% niveau de confiance:")
print(VaR)

annual_volatility

from pypfopt.cla import CLA
from pypfopt.plotting import plot_efficient_frontier

cla = CLA(mu, S)
cla.max_sharpe()
weights = cla.clean_weights()
print(weights)

# Tracez la frontière efficace
ax = plot_efficient_frontier(cla, show_assets=True)
plt.title('Frontière Efficiente')
plt.xlabel('Volatilité')
plt.ylabel('Rendement')

# Afficher le graphique
plt.show()

'''
  ________                    .__                       .__  __
 /  _____/ __ __   ____  ____ |__| ______   ____ ______ |__|/  |_  ____
/   \  ___|  |  \_/ ___\/ ___\|  | \____ \_/ __ \\____ \|  \   __\/  _ \
\    \_\  \  |  /\  \__\  \___|  | |  |_> >  ___/|  |_> >  ||  | (  <_> )
 \______  /____/  \___  >___  >__| |   __/ \___  >   __/|__||__|  \____/
        \/            \/    \/     |__|        \/|__|
__________                    .___.__        __  .__                   _____             .___     .__
\______   \_______   ____   __| _/|__| _____/  |_|__| ____   ____     /     \   ____   __| _/____ |  |
 |     ___/\_  __ \_/ __ \ / __ | |  |/ ___\   __\  |/  _ \ /    \   /  \ /  \ /  _ \ / __ |/ __ \|  |
 |    |     |  | \/\  ___// /_/ | |  \  \___|  | |  (  <_> )   |  \ /    Y    (  <_> ) /_/ \  ___/|  |__
 |____|     |__|    \___  >____ | |__|\___  >__| |__|\____/|___|  / \____|__  /\____/\____ |\___  >____/
                        \/     \/         \/                    \/          \/            \/    \/
'''


import yfinance as yf
import numpy as np
import pandas as pd
import datetime as dt
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error

# 1. Function to plot 3D implied volatility surface
def plot_volatility_surface(ticker, expiry_date):
    # Retrieve option chain data from yfinance
    stock = yf.Ticker(ticker)
    options = stock.option_chain(expiry_date)
    calls = options.calls

    # Calculate implied volatility (IV) for each option
    ivs = []
    strikes = []
    maturities = []

    for i, option in calls.iterrows():
        strike = option['strike']
        expiration = dt.datetime.strptime(expiry_date, '%Y-%m-%d')
        maturity = (expiration - dt.datetime.now()).days / 365.0
        iv = option['impliedVolatility']

        # Adding a small jitter to the strikes and maturities to avoid singular input data
        strikes.append(strike + np.random.normal(0, 0.01))
        maturities.append(maturity + np.random.normal(0, 0.01))
        ivs.append(iv)

    # Convert lists to numpy arrays
    strikes = np.array(strikes)
    maturities = np.array(maturities)
    ivs = np.array(ivs)

    # Create 3D plot
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_trisurf(strikes, maturities, ivs, cmap='viridis')
    ax.set_xlabel('Strike Price')
    ax.set_ylabel('Time to Expiration (years)')
    ax.set_zlabel('Implied Volatility')
    ax.set_title(f'Implied Volatility Surface for {ticker}')
    plt.show()

# Example usage:
# plot_volatility_surface('BFH', '2024-08-16')


from sklearn.linear_model import LinearRegression

# Function to predict stock prices considering multiple lags and forecast days
def predict_stock_prices_advanced(ticker, forecast_days=7):
    # Download historical data
    stock = yf.Ticker(ticker)
    hist = stock.history(period='1y')

    # Prepare the dataset
    hist['Return'] = hist['Close'].pct_change()
    for lag in range(1, forecast_days + 1):
        hist[f'Lag{lag}'] = hist['Return'].shift(lag)
    hist.dropna(inplace=True)

    # Select features based on the number of forecast days
    feature_cols = [f'Lag{lag}' for lag in range(1, forecast_days + 1)]
    X = hist[feature_cols]
    y = hist['Close']

    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Train a random forest regressor
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Predicting the next price
    latest_data = pd.DataFrame([X.iloc[-1]], columns=feature_cols)  # Ensure feature names are preserved
    prediction = model.predict(latest_data)

    # Calculate win rate
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    win_rate = 1 - np.sqrt(mse) / y_test.mean()

    print(f"Predicted price for {ticker} in {forecast_days} days: ${prediction[0]:.2f}")
    print(f"Model Win Rate: {win_rate:.2%}")
    return prediction, win_rate

import matplotlib.pyplot as plt
import numpy as np
import yfinance as yf

def plot_prediction(ticker, forecast_days, predicted_price, win_rate):
    # Download historical data
    stock = yf.Ticker(ticker)
    hist = stock.history(period='1y')
    dates = hist.index

    # Plot the historical close prices
    plt.figure(figsize=(14, 7))
    plt.plot(dates, hist['Close'], label='Historical Close Prices', color='blue')

    # Plot the predicted price
    future_date = dates[-1] + np.timedelta64(forecast_days, 'D')
    plt.plot(future_date, predicted_price, 'ro', label=f'Predicted Price in {forecast_days} Days')

    # Annotate the predicted price and win rate
    plt.annotate(f'Predicted Price: ${predicted_price[0]:.2f}\nWin Rate: {win_rate:.2%}',
                 xy=(future_date, predicted_price), xytext=(future_date, predicted_price[0] + 10),
                 arrowprops=dict(facecolor='black', shrink=0.05), fontsize=12, color='red')

    # Labeling the plot
    plt.title(f'{ticker} Price Prediction for the Next {forecast_days} Days')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()
    plt.grid(True)

    # Show the plot
    plt.show()

plot_volatility_surface('BFH', '2024-08-16')

predict_stock_prices_advanced('BFH', 7)

# Example usage:
predicted_price = np.array([45.66])
win_rate = 0.8257
plot_prediction('BFH', 7, predicted_price, win_rate)

predict_stock_prices_advanced('SDE.TO', 7)

# Example usage:
predicted_price = np.array([4.05])
win_rate = 0.8738
plot_prediction('SDE.TO', 7, predicted_price, win_rate)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn import metrics

import warnings
warnings.filterwarnings('ignore')



# -*- coding: utf-8 -*-
"""

________  ___  ___  ________  ________  ___  ________  _______   ________  ___  _________  ________
|\   ____\|\  \|\  \|\   ____\|\   ____\|\  \|\   __  \|\  ___ \ |\   __  \|\  \|\___   ___\\   __  \
\ \  \___|\ \  \\\  \ \  \___|\ \  \___|\ \  \ \  \|\  \ \   __/|\ \  \|\  \ \  \|___ \  \_\ \  \|\  \
 \ \  \  __\ \  \\\  \ \  \    \ \  \    \ \  \ \   ____\ \  \_|/_\ \   ____\ \  \   \ \  \ \ \  \\\  \
  \ \  \|\  \ \  \\\  \ \  \____\ \  \____\ \  \ \  \___|\ \  \_|\ \ \  \___|\ \  \   \ \  \ \ \  \\\  \
   \ \_______\ \_______\ \_______\ \_______\ \__\ \__\    \ \_______\ \__\    \ \__\   \ \__\ \ \_______\
    \|_______|\|_______|\|_______|\|_______|\|__|\|__|     \|_______|\|__|     \|__|    \|__|  \|_______|


____ ___ ____ ____ _  _    ____ ___  ___ _ ____ _  _ ____    ____ _  _ ____ _    _   _ ____ _ ____    ___ ____ ____ _
[__   |  |  | |    |_/     |  | |__]  |  | |  | |\ | [__     |__| |\ | |__| |     \_/  [__  | [__      |  |  | |  | |
___]  |  |__| |___ | \_    |__| |     |  | |__| | \| ___]    |  | | \| |  | |___   |   ___] | ___]     |  |__| |__| |___



"""


import subprocess
import os
import numpy as np
from scipy.stats import norm
from datetime import datetime
import yfinance as yf
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Alignment, Font
from google.colab import files
from pandas_datareader import data as pdr

# Install necessary libraries
subprocess.run(['pip', 'install', 'yfinance', 'numpy', 'scipy', 'pandas_datareader'])

def get_option_expiration_dates(symbol):
    """
    Gets the expiration dates of options for a given symbol.

    Args:
    symbol: Stock symbol

    Returns:
    List of option expiration dates
    """
    ticker = yf.Ticker(symbol)  # Retrieving ticker data
    expirations = ticker.options  # Retrieving option expiration dates
    return expirations

def calculate_implied_volatility(S, K, T, r, price, option_type):
    """
    Calculates the implied volatility using the Black-Scholes model.

    Args:
    S: Current stock price
    K: Option strike price
    T: Time to expiration in years
    r: Risk-free interest rate
    price: Option price
    option_type: 'call' or 'put'

    Returns:
    Implied volatility
    """
    tol = 0.0001  # Tolerance for implied volatility convergence
    max_iter = 100  # Maximum number of iterations

    def black_scholes(option_type, S, K, T, r, sigma):
        """
        Calculates the option price using the Black-Scholes model.
        """
        d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)

        if option_type == 'call':
            option_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
        else:
            option_price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

        return option_price

    sigma = 0.5  # Initial guess for implied volatility
    price_est = black_scholes(option_type, S, K, T, r, sigma)  # Initial estimate of option price
    diff = price_est - price  # Difference between estimated price and observed price
    iter_count = 0  # Iteration counter initialization

    while abs(diff) > tol and iter_count < max_iter:
        vega = S * np.sqrt(T) * norm.pdf((np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T)))
        price_est = black_scholes(option_type, S, K, T, r, sigma)  # Estimate of option price
        diff = price_est - price  # New difference between estimated price and observed price

        if abs(diff) < tol:  # Checking for convergence
            break

        sigma = sigma - (diff / vega)  # Updating implied volatility
        iter_count += 1  # Incrementing iteration counter

    return sigma

def calculate_intrinsic_value(S, K, option_type):
    """
    Calculates the intrinsic value of an option.

    Args:
    S: Current stock price
    K: Option strike price
    option_type: 'call' or 'put'

    Returns:
    Intrinsic value
    """
    if option_type == 'call':
        return max(0, S - K)
    else:
        return max(0, K - S)

def calculate_time_value(price, intrinsic_value):
    """
    Calculates the time value of an option.

    Args:
    price: Option price
    intrinsic_value: Intrinsic value of the option

    Returns:
    Time value
    """
    return max(0, price - intrinsic_value)

def calculate_historical_volatility(symbol, start_date, end_date):
    """
    Calculates historical volatility using historical price data.

    Args:
    symbol: Stock symbol
    start_date: Start date for historical data
    end_date: End date for historical data

    Returns:
    Historical volatility
    """
    stock = yf.Ticker(symbol)  # Retrieving stock data
    historical_data = stock.history(start=start_date, end=end_date)  # Retrieving historical data
    returns = np.log(historical_data['Close'] / historical_data['Close'].shift(1))  # Calculating log returns
    volatility = returns.std() * np.sqrt(252)  # Calculating historical volatility (252 trading days in a year)
    return volatility

def get_risk_free_rate():
    """
    Gets the risk-free rate using the 10-year Treasury constant maturity rate.
    """
    risk_free_rate_data = pdr.get_data_fred('DGS10')
    return risk_free_rate_data['DGS10'][-1] / 100  # Convert percentage to decimal

def fetch_option_info(ticker, expiry_date, risk_free_rate):
    """
    Fetches option information for a given ticker, expiry date, and risk-free rate.

    Args:
    ticker: Stock ticker
    expiry_date: Option expiration date
    risk_free_rate: Risk-free interest rate

    Returns:
    Option information
    """
    stock = yf.Ticker(ticker)  # Retrieving stock data
    trade_date = datetime.now()  # Current date
    trade_date = trade_date.replace(tzinfo=None)  # Converting to datetime without timezone

    expiry_date = datetime.strptime(expiry_date, '%Y-%m-%d').replace(tzinfo=None)  # Converting expiration date to datetime object

    if expiry_date < trade_date:
        raise ValueError("The specified expiration date has already passed.")

    option_chain = stock.option_chain(expiry_date.strftime('%Y-%m-%d'))  # Retrieving option chain data
    if len(option_chain.calls) > 0:
        option = option_chain.calls.iloc[0]  # Assuming you're interested in the first available call option
        underlying_price = stock.history(period='1d').iloc[-1]['Close']  # Underlying stock price
        strike_price = option['strike']  # Option strike price

        days_to_expiry = (expiry_date - trade_date).days / 365  # Time to expiration in years

        # Calculating implied volatility
        implied_volatility = calculate_implied_volatility(underlying_price, strike_price, days_to_expiry, risk_free_rate, option['lastPrice'], 'call')

        # Calculating intrinsic value for call option
        call_intrinsic_value = calculate_intrinsic_value(underlying_price, strike_price, 'call')

        # Calculating intrinsic value for put option
        put_intrinsic_value = calculate_intrinsic_value(underlying_price, strike_price, 'put')

        # Calculating time value
        time_value = calculate_time_value(option['lastPrice'], call_intrinsic_value)

        return underlying_price, strike_price, days_to_expiry, risk_free_rate, implied_volatility, call_intrinsic_value, put_intrinsic_value, time_value
    else:
        raise ValueError("No call option available for the given ticker and expiry date.")

def main():
    symbol = input("Enter the stock symbol: ")
    risk_free_rate = get_risk_free_rate()
    expiration_dates = get_option_expiration_dates(symbol)

    if expiration_dates:
        option_data_list = []
        for exp_date in expiration_dates:
            try:
                option_data = fetch_option_info(symbol, exp_date, risk_free_rate)
                # Calculating historical volatility
                start_date = (datetime.now() - pd.Timedelta(days=365)).strftime('%Y-%m-%d')  # One year ago
                end_date = datetime.now().strftime('%Y-%m-%d')
                historical_volatility = calculate_historical_volatility(symbol, start_date, end_date)
                option_data_list.append([exp_date] + list(option_data) + [historical_volatility])
            except ValueError as e:
                print(e)

        # Creating a DataFrame with option data
        columns = ['Expiration Date', 'Underlying Price', 'Strike Price', 'Days to Expiry', 'Risk-Free Rate', 'Implied Volatility', 'Call Intrinsic Value', 'Put Intrinsic Value', 'Time Value', 'Historical Volatility']
        df = pd.DataFrame(option_data_list, columns=columns)

        # Counting the number of existing files for the same ticker
        num_files = sum(f.startswith(f"{symbol}_option_data") for f in os.listdir('.'))
        num_files += 1

        # Exporting data to an Excel file with increasing numbering
        excel_file = f"{symbol}_option_data_{num_files}.xlsx"
        with pd.ExcelWriter(excel_file, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Option Data')

            # Applying style to the Excel file
            workbook = writer.book
            worksheet = writer.sheets['Option Data']
            header_font = Font(bold=True)
            align_center = Alignment(horizontal='center')
            for cell in worksheet["1:1"]:
                cell.font = header_font
                cell.alignment = align_center

            # Adding a title
            title_cell = worksheet.cell(row=1, column=1)
            title_cell.value = "Option Data"
            title_cell.font = Font(size=14, bold=True)
            title_cell.alignment = Alignment(horizontal='center')

            # Automatically adjusting column widths
            for column_cells in worksheet.columns:
                max_length = 0
                column = column_cells[0].column_letter
                for cell in column_cells:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(cell.value)
                    except:
                        pass
                adjusted_width = (max_length + 2) * 1.2
                worksheet.column_dimensions[column].width = adjusted_width

        print(f"Option data has been saved to {excel_file}")

        # Downloading the Excel file
        files.download(excel_file)
    else:
        print("No option expiration dates found for {}".format(symbol))

if __name__ == "__main__":
    main()

# -*- coding: utf-8 -*-
"""

________  ___  ___  ________  ________  ___  ________  _______   ________  ___  _________  ________
|\   ____\|\  \|\  \|\   ____\|\   ____\|\  \|\   __  \|\  ___ \ |\   __  \|\  \|\___   ___\\   __  \
\ \  \___|\ \  \\\  \ \  \___|\ \  \___|\ \  \ \  \|\  \ \   __/|\ \  \|\  \ \  \|___ \  \_\ \  \|\  \
 \ \  \  __\ \  \\\  \ \  \    \ \  \    \ \  \ \   ____\ \  \_|/_\ \   ____\ \  \   \ \  \ \ \  \\\  \
  \ \  \|\  \ \  \\\  \ \  \____\ \  \____\ \  \ \  \___|\ \  \_|\ \ \  \___|\ \  \   \ \  \ \ \  \\\  \
   \ \_______\ \_______\ \_______\ \_______\ \__\ \__\    \ \_______\ \__\    \ \__\   \ \__\ \ \_______\
    \|_______|\|_______|\|_______|\|_______|\|__|\|__|     \|_______|\|__|     \|__|    \|__|  \|_______|


_  _ ____ _  _ ___ ____    ____ ____ ____ _    ____    ____ _ _  _ _  _ _    ____ ___ _ ____ _  _
|\/| |  | |\ |  |  |___    |    |__| |__/ |    |  |    [__  | |\/| |  | |    |__|  |  | |  | |\ |
|  | |__| | \|  |  |___    |___ |  | |  \ |___ |__|    ___] | |  | |__| |___ |  |  |  | |__| | \|



"""

# Installation of necessary libraries

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from datetime import datetime
from scipy.stats import norm  # Import norm from scipy.stats for Gaussian functions

# Downloading historical stock data
def download_stock_data(ticker, start_date, end_date):
    """Download historical stock data from Yahoo Finance.

    Parameters:
    ticker (str): Ticker symbol of the stock.
    start_date (str): Start date of the historical data (YYYY-MM-DD).
    end_date (str): End date of the historical data (YYYY-MM-DD).

    Returns:
    pandas.Series: Close prices of the stock.
    str: Short name of the stock.
    """
    stock = yf.Ticker(ticker)
    data = stock.history(start=start_date, end=end_date)
    return data['Close'], stock.info['shortName']

# Monte Carlo simulation for theoretical future stock price with Gaussian distribution
def monte_carlo_simulation(data, num_simulations, num_days, short_name):
    """Perform Monte Carlo simulation for predicting future stock prices.

    Parameters:
    data (pandas.Series): Historical stock price data.
    num_simulations (int): Number of simulations to run.
    num_days (int): Number of days to simulate into the future.
    short_name (str): Short name of the stock.

    Returns:
    pandas.Series: Last simulated prices.
    float: Average predicted price after all simulations.
    """
    returns = (data / data.shift(1) - 1).dropna()
    last_price = data[-1]
    simulation_df = pd.DataFrame()

    for x in range(num_simulations):
        count = 0
        daily_vol = returns.std()
        price_series = []
        price = last_price * np.exp((0.5 * daily_vol**2) + daily_vol * norm.ppf(np.random.rand()))
        price_series.append(price)

        for y in range(num_days - 1):
            if count == 251:
                break
            price = price_series[count] * np.exp((0.5 * daily_vol**2) + daily_vol * norm.ppf(np.random.rand()))
            price_series.append(price)
            count += 1

        simulation_df[x] = price_series

    plt.figure(figsize=(10, 6))
    plt.plot(simulation_df)
    plt.axhline(simulation_df.iloc[-1].mean(), color='green', linestyle='--', linewidth=1, label='Prix moyen prédit : {:.2f}'.format(simulation_df.iloc[-1].mean()))
    plt.axhline(last_price, color='gray', linestyle='--', linewidth=1, label='Prix actuel : {:.2f}'.format(last_price))
    plt.xlabel('Jours')
    plt.ylabel('Prix de l\'action')
    plt.title('Simulation de Monte Carlo pour le prix théorique futur de {}'.format(short_name))
    plt.legend()
    plt.show()

    average_predicted_price = simulation_df.iloc[-1].mean()

    # Tracer la distribution gaussienne
    plt.figure(figsize=(10, 6))
    plt.hist(simulation_df.iloc[-1], bins=30, density=True, alpha=0.6, color='g', edgecolor='black')
    plt.title('Distribution des prix finaux des actions')
    plt.xlabel('Prix de l\'action')
    plt.ylabel('Densité')


    # Plotting the Gaussian distribution curve
    xmin, xmax = plt.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = norm.pdf(x, simulation_df.iloc[-1].mean(), simulation_df.iloc[-1].std())
    plt.plot(x, p, 'k', linewidth=2)

    plt.show()

    return simulation_df.iloc[-1], average_predicted_price

# Parameters
ticker = 'SDE.TO'  # Stock ticker symbol (Tesla in this example)
start_date = '2020-01-01'  # Start date of historical data
end_date = datetime.now().strftime("%Y-%m-%d")  # End date of historical data (today's date)
num_simulations = 10000  # Number of Monte Carlo simulations
num_days = 252  # Number of days for the simulation

# Downloading historical data
stock_data, short_name = download_stock_data(ticker, start_date, end_date)

# Monte Carlo Simulation
monte_carlo_prices, average_predicted_price = monte_carlo_simulation(stock_data, num_simulations, num_days, short_name)

# Calcul du VaR
confidence_level = 0.95  # 99% confidence level
VaR = np.percentile(monte_carlo_prices, (1 - confidence_level) * 100)

# Afficher les résultats statistiques supplémentaires
print("\nPrix moyen prédit après toutes les simulations avec Monte Carlo:", average_predicted_price)
print("Écart-type des prix des actions finaux:", monte_carlo_prices.std())
print("Prix maximal prédit:", monte_carlo_prices.max())
print("Prix minimal prédit:", monte_carlo_prices.min())
print(f"VaR à {confidence_level*100}% de confiance : {VaR:.2f}")

# Visualiser les résultats
plt.figure(figsize=(10, 6))
plt.hist(monte_carlo_prices, bins=50, alpha=0.75, color='blue')
plt.axvline(x=VaR, color='r', linestyle='--', label=f'VaR à {confidence_level*100}%: {VaR:.2f}')
plt.title('Distribution des prix finaux simulés et VaR')
plt.xlabel('Prix de l\'action')
plt.ylabel('Fréquence')
plt.legend()
plt.show()